<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>Carrier Routes Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" integrity="sha256-kLaT2GOSpHechhsozzB+flnD+zUyjE2LlfWPgU04xyI=" crossorigin="" />
    <link rel="stylesheet" href="/map.css" />
    <script src="https://unpkg.com/leaflet@1.9.3/dist/leaflet.js" integrity="sha256-WBkoXOwTeyKclOHuWtc+i2uENFpDZ9YPdf5Hf+D7ewM=" crossorigin=""></script>
    <script src="/leaflet/vendor/Leaflet.fullscreen/Leaflet.fullscreen.js"></script>
    <script src="/leaflet/vendor/Leaflet.TextPath/leaflet.textpath.js"></script>
    <script src="/leaflet/vendor/Leaflet.fullscreen/Leaflet.fullscreen.min.js"></script>
    <script src="/leaflet/controls/L.Control.TemplateButton/L.Control.TemplateButton.js"></script>
    <script src="/leaflet/controls/L.Marker.Classed/L.Marker.Classed.js"></script>
    <script src="/leaflet/L.SVG.groupedPaths.js"></script>
    <script src="/leaflet/L.TipCircle.js"></script>
    <!-- Template for Reset View control -->
    <script type="text/html" id="ResetButtonTemplate">
        <div class="leaflet-control-templatebutton leaflet-bar leaflet-control">
            <a class="leaflet-bar-part leaflet-bar-part-single montserrat" title="Reset map to original view" href="#" role="button">
                <span class="leaflet-control-templatebutton-icon fa fa-undo" aria-hidden="true"></span>
            </a>
        </div>
    </script>

</head>
<body>
    <meta name="viewport" content="width=device-width" />
    <div id="map" class="map"></div>

    <script>
    const METERS_PER_MILE = 1609.34;
    const RAD_PER_DEGREE = Math.PI / 180.0;
    const LOCALE = 'en-US';

    let LMN = L.latLng(42.703772, -84.537131);
    let mapOptions = {
        zoomSnap: 0.5,
        center: LMN,
        zoom: 12
    };

    // Shortcut function for formatting.
    let toNum = function(num, options) {
        return num.toLocaleString(LOCALE, options);
    }

    // Create the map
    var map = L.map("map", mapOptions);

    map.createPane('labels');
    map.getPane('labels').style.zIndex = 550;
    map.getPane('labels').style.pointerEvents = 'none';

    map.createPane('underlay').style.zIndex=390;

    // Tracks data loading requests
    let requests = [];

    // Histogram bins for grouping and summarizing
    let histogram = [
        { minValue: 115000, color:'#800026', group: L.layerGroup(), stats: { residences: 0, businesses: 0, routes: 0 }},
        { minValue: 100000, color:'#BD0026', group: L.layerGroup(), stats: { residences: 0, businesses: 0, routes: 0 }},
        { minValue: 85000, color:'#E31A1C', group: L.layerGroup(), stats: { residences: 0, businesses: 0, routes: 0 }},
        { minValue: 70000, color:'#FC4E2A', group: L.layerGroup(), stats: { residences: 0, businesses: 0, routes: 0 }},
        { minValue: 55000, color:'#FD8D3C', group: L.layerGroup(), stats: { residences: 0, businesses: 0, routes: 0 }},
        { minValue: 40000, color:'#FEB24C', group: L.layerGroup(), stats: { residences: 0, businesses: 0, routes: 0 }},
        { minValue: 25000, color:'#FED976', group: L.layerGroup(), stats: { residences: 0, businesses: 0, routes: 0 }},
        { minValue: 0, color:'#FFEDA0', group: L.layerGroup(), stats: { residences: 0, businesses: 0, routes: 0 }},
    ];

    function getColor(m) {
        for (bin of histogram) {
            if (m >= bin.minValue) return bin.color;
        }
    }

    let selectedFeature = null;

    let featureClick = function(e) {
        if (selectedFeature) {
            L.geoJSON().resetStyle(selectedFeature);
        }
        selectedFeature = e.target;
        selectedFeature.bringToFront();
        selectedFeature.setStyle({ className: 'carrier-route-selected', color: 'blue'});
    }

    // Add layers
    // let osmUrl = 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
    // let osmAttribution = '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>';
    // L.tileLayer(osmUrl, {
    //     maxZoom: 18,
    //     minZoom: 1,
    //     attribution: osmAttribution
    // }).addTo(map);

    var CartoDB_VoyagerNoLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_nolabels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        maxZoom: 20
    }).addTo(map);

    var CartoDB_VoyagerOnlyLabels = L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager_only_labels/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
        subdomains: 'abcd',
        pane: 'labels',
        maxZoom: 20
    }).addTo(map);

    L.control.fullscreen({
        position: "topleft"
    }).addTo(map);

    L.control.scale({
        position: "bottomright"
    }).addTo(map);

    let lmnMarker = L.marker(LMN, { title: "LMN Headquarters" }).addTo(map);

    let circles = [
        { radMiles: 20, color: '#afa5e8', minRadius: 9, stats: { residences: 0, businesses: 0, routes: 0 } },
        { radMiles: 10, color: '#c0b5ff', minRadius: 10, stats: { residences: 0, businesses: 0, routes: 0 } },
        { radMiles: 5, color: '#e9e6ff', minRadius: 10, stats: { residences: 0, businesses: 0, routes: 0 } },
        { radMiles: 2, color: '#edc4ff', minRadius: 11, stats: { residences: 0, businesses: 0, routes: 0 } },
        { radMiles: 1, color: '#e3a3ff', minRadius: 12, stats: { residences: 0, businesses: 0, routes: 0 } },
    ];

    let circleGroup = L.layerGroup();
    for (c of circles) {
        let layer = L.circle(LMN, c.radMiles * 1609, {
            containerName: 'distance-circles',
            className: 'distance-circle',
            minZoom: c.minRadius,
            color: '#333333', fillOpacity: 0, opacity: 0.5, stroke: true, width: 2, dashArray: "1 5"
        });
        c.layer = layer;
        layer.addTo(map);
        c.icon = L.divIcon({
            iconSize: null,
            className: 'distance-marker',
            minZoom: c.minRadius,
            html: `<div class='distance-marker-content'>${c.radMiles} mile distance</div>`
        });
        let pos = [ layer.getBounds()._southWest.lat, layer.getLatLng().lng];
        c.marker = L.marker(pos, { icon: c.icon }).addTo(map);
        circleGroup.addLayer(layer);
    }
    //circleGroup.addTo(map);

    let isochrones = [
        { minutes: 10, color: '#222266'},
        { minutes: 20, color: '#662222'},
        { minutes: 30, color: '#226622'},
    ];
    let isochronesGroup = L.layerGroup();

    // Renders isochrone layer with given options
    let isoHandler = function(options, data) {
        let layer = L.geoJSON(data, { style:
            { containerName: 'isochrones',
                color: options.color,
                opacity: 0.75,
                fillOpacity: 0.05,
                width: 1,
                dashArray: '6 6',
                lineCap: 'butt'
        }});
        layer.bindTooltip(`${options.minutes}-minute driving distance`, { permanent: false, sticky: true, direction: 'center' });
        isochronesGroup.addLayer(layer);
    }

    for (iso of isochrones) {
        url = `/data/isochrone-${iso.minutes}min.geojson`;
        fetch(url)
        .then(response => response.json())
        .then(isoHandler.bind(this, iso)) // Invoke isoHandler with this bound to this and options bound to iso.
        .catch((error) => { console.error(`There was a problem fetching or processing map data for ${url} : `, error);  })
    }
    isochronesGroup.addTo(map);

    // Add layers control to select histogram bins
    let layerControl = L.control.layers(null, null, { collapsed: false, position: 'bottomright' });
    histogram.map(bin => {
        layerControl.addOverlay(bin.group, `\$${bin.minValue.toLocaleString(LOCALE)}`);
    });
    layerControl.addOverlay(isochronesGroup, 'Isochrones');
    layerControl.addTo(map);


    function styleRoute(feature) {
        return {
            color: getColor(feature.properties.MED_INCOME),
            weight: 3,
            opacity: 1,
            className: "carrier-route"
        };
    }

    function styleRouteBackground(feature) {
        return {
            color: '#fff',
            weight: 6,
            className: `route-facility-${feature.properties.FACILITY_NAME}`
        }
    }

    // For a GeoJSON feature, find the nearest and furthest distances from
    // the reference point. Uses an approximation valid for points close
    // to the reference point. "Close" in this case means "not too far away".
    // Returns { min: distMeters, max: distMeters }
    function computeRouteDistances(feature, refPoint) {

        // From https://stackoverflow.com/questions/43167417/calculate-distance-between-two-points-in-leaflet
        // var deltaLat = lat2 - lat1;
        // var deltaLon = lon2 - lon1;

        // var a = Math.pow(Math.sin(deltaLat/2), 2) + Math.cos(lat1) * Math.cos(lat2) * Math.pow(Math.sin(deltaLon/2), 2);
        // var c = 2 * Math.asin(Math.sqrt(a));
        // var EARTH_RADIUS = 6371;
        // return c * EARTH_RADIUS

        // For "close" points, cos(lat1) ~ cos(lat2)

        creflat = Math.cos(refPoint.lat * RAD_PER_DEGREE);

        
        // Compute min and max ref point
        let aMin = 1000000000.0, aMax = 0.0;

        const EARTH_RADIUS = 6378100;
        switch (feature.geometry.type) {
            case "MultiLineString":
                for (line of feature.geometry.coordinates) {
                    for (point of line) {
                        deltaLat = Math.abs(point[1] - refPoint.lat) * RAD_PER_DEGREE;
                        deltaLon = Math.abs(point[0] - refPoint.lng) * RAD_PER_DEGREE;

                        let a = Math.pow(Math.sin(deltaLat/2), 2)
                              + creflat * Math.cos(point[1] * RAD_PER_DEGREE) * Math.pow(Math.sin(deltaLon/2), 2);

                        if (a < aMin) aMin = a;
                        if (a > aMax) aMax = a;
                    }
                }
            break;
        }

        if (aMax== 0.0) {
            // No points processed
            return null;
        }

        let cMin = 2 * Math.asin(Math.sqrt(aMin));
        let cMax = 2 * Math.asin(Math.sqrt(aMax));

        return { minDist: cMin * EARTH_RADIUS, maxDist: cMax * EARTH_RADIUS };
    }

    function processRoute(feature, layer) {
        let props = feature.properties;
        let m = props.MED_INCOME;
        
        let d = computeRouteDistances(feature, LMN);
        props.minDist = d.minDist;
        props.maxDist = d.maxDist;

        let format = { maximumFractionDigits: 1};
        let tip = `<h3>${props.ZIP_CRID}</h3><p>${(props.minDist/METERS_PER_MILE).toLocaleString(LOCALE, format)}mi &ndash; ${(props.maxDist/METERS_PER_MILE).toLocaleString(LOCALE, format)}mi</p><table><tr><th>Med. Income</th><td align='right'>\$${props.MED_INCOME.toLocaleString(LOCALE)}<tr><th>Residences</th><td align='right'>${props.RES_CNT.toLocaleString(LOCALE)}</td></tr><tr><th>Businesses</th><td align='right'>${props.BUS_CNT.toLocaleString(LOCALE)}</td></tr><tr><th>Facility</th><td align='right'>${props.FACILITY_NAME}<tr></table>`;

        layer.options.containerName = "carrier-routes";
        layer.bindTooltip(tip, { className: 'carrier-route', permanent: false, sticky: true, direction: 'top', offset: L.point(0, -40) });

        // Add layers to group for histogram bin
        for (bin of histogram) {
            if (m >= bin.minValue) {
                bin.stats.residences += feature.properties.RES_CNT;
                bin.stats.businesses += feature.properties.BUS_CNT;
                bin.stats.routes += 1;
                bin.group.addLayer(layer);
                break;
            }
        }

        // Accumulate statistics for distance circles
        for (circ of circles) {
            if (d.minDist < circ.radMiles * METERS_PER_MILE) {
                let stats = circ.stats;
                stats.residences += feature.properties.RES_CNT;
                stats.businesses += feature.properties.BUS_CNT;
                stats.routes += 1;
            }
        }

        layer.on('click', featureClick);
    };

    function processRouteBackground(feature, layer) {  
        layer.addTo(map);
    }


    let zips = [ 48910, 48911, 48933, 48912, 48915, 48842, 48917, 48823, 48906, 48864, 48821, 48840, 48854, 48808, 48820, 48876, 48837, 48895, 48848, 48822, 48827, 48819, 49251, 48872, 48813, 49264, 48892, 48894, 48879, 48875 ];

    zips.forEach ((zip) => {
        url = `/data/routes-${zip}.geojson`;

        requests.push(
            fetch(url)
            .then(response => response.json())
            .then(data => {
                L.geoJSON(data, { style: styleRoute, onEachFeature: processRoute });
            })
            .catch((error) => {
                console.error(`There was a problem fetching or processing map data for ${url} : `, error);
            }));
    });

    // Add histgram layer groups to map
    for (bin of histogram) {
        bin.group.addTo(map);
    }

    // When all features processed, build a legend
    Promise.all(requests).then(function () {
        // Create legend
        var legend = L.control({ position: "bottomleft" });

        legend.onAdd = function(map) {
            var div = L.DomUtil.create("div", "legend leaflet-control");
            let markup = "<h4>Legend</h4>";
            markup += "<table><tr><th>Income</th><th align='right'>Res.</th><th align='right'>Bus.</th><th align='right'>Routes</tr>";
            for (bin of histogram) {
                stats = bin.stats;
                markup += `<tr><td align='right'><i style="background: ${bin.color}"></i><span>\$${bin.minValue.toLocaleString(LOCALE)}+</td><td align='right'>${stats.residences.toLocaleString(LOCALE)}</td><td align='right'>${stats.businesses.toLocaleString(LOCALE)}</td><td align='right'>${stats.routes}</td></tr>`;
            }
            markup += "</table>";

            div.innerHTML += markup;
            return div;
        };

        legend.addTo(map);

        // Add legend popups to circles
        for (circ of circles) {
            let markup = `<h4>${circ.radMiles}-mile Distance</h4>`;
            let stats = circ.stats;
            markup += `<table><tr><th>Residences</th><td align='right'>${toNum(stats.residences)}</td></tr>`;
            markup += `<tr><th>Businesses</th><td align='right'>${toNum(stats.businesses)}</td></tr>`;
            markup += `<tr><th>Routes</th><td align='right'>${toNum(stats.routes)}</td></tr>`;
            markup += "</table>";

            circ.marker.bindPopup(markup, { direction: 'top'});
        }
    });

    </script>

</body>
</html>